@import "../lib/common.js";

var onRun = function(context) {

    ga(context, "Export", "export_vector_drawable");

    // SVG2VectorDrawable
    var s2v = which("s2v");
    if (!s2v) {
        alert(
            context,
            localizedString(context, "install_s2v_title"),
            localizedString(context, "install_s2v_message")
        );
        return;
    }

    // Check SVG2VectorDrawable version
    var s2vVersion = checkVersion(s2v);
    if (versionCompare(s2vVersion, "2.0.0") == -1) {
        alert(
            context,
            localizedString(context, "s2v_version_title"),
            localizedString(context, "s2v_version_message")
        );
        return;
    }

    var doc = context.document;
    var selection = context.selection;

    var exportVectorAssets;
    if (selection.count() > 0) {
        exportVectorAssets = getVectorAssetFromSelection(context);
    } else {
        exportVectorAssets = getVectorAssetFromDocument(context);
    }

    if (exportVectorAssets.count() == 0) {
        toast(context, localizedString(context, "no_vector_drawable_asset"));
        return;
    }

    var exportFolder = chooseFolder();
    if (exportFolder) {

        // ExportFolder is writeable
        if (!directoryIsWriteable(exportFolder)) {
            toast(context, localizedString(context, "cannot_export_to_folder"));
            return;
        }

        var assetNameType = getPreferences(context, "asset_name_type");

        var loopExportVectors = exportVectorAssets.objectEnumerator();
        var slice;
        while (slice = loopExportVectors.nextObject()) {

            var vectorAssetGroup = slice.parentGroup();
            var vectorAssetGroupCopy = vectorAssetGroup.duplicate();

            var loopAssetChildren = vectorAssetGroupCopy.children().objectEnumerator();
            var layer;
            while (layer = loopAssetChildren.nextObject()) {
                if (
                    layer.class() == "MSBitmapLayer" ||
                    layer.class() == "MSTextLayer" ||
                    layer.class() == "MSSymbolInstance"
                ) {
                    layer.removeFromParent();
                }

                var style = layer.style();

                style.removeAllStyleShadows();
                style.removeAllStyleInnerShadows();
                style.blur().setIsEnabled(false);
                style.contextSettings().setBlendMode(0);

                var lastSupportedFill;
                style.fills().forEach(function(fill) {
                    if (fill.isEnabled() == true && (fill.fillType() == 0 || fill.fillType() == 1)) {
                        lastSupportedFill = fill;
                    }
                });
                style.removeAllStyleFills();
                style.addStyleFill(lastSupportedFill);

                


            }


            // var svgFile = exportFolder + "/" + slice.objectID() + ".svg";
            // doc.saveArtboardOrSlice_toFile(slice, svgFile);

            // svg2vector(s2v, svgFile, exportFolder + "/drawable-anydpi-v21/" + vector.name + ".xml");
            //
            // rm(svgFile);

        }

        if (getPreferences(context, "show_in_finder_after_export") == 1) {
            showInFinder(exportFolder + "/drawable-anydpi-v21");
        }

    }

}

function getVectorAssetFromSelection(context) {
    var assets = NSMutableArray.alloc().init();
    var predicate = NSPredicate.predicateWithFormat(
        'className == "MSSliceLayer" && name != "#9patch" && exportOptions.firstFormat == "svg"'
    );
    var selection = context.selection;
    selection.forEach(function(layer) {
        assets.addObjectsFromArray(layer.children().filteredArrayUsingPredicate(predicate));
    });
    return assets;
}

function getVectorAssetFromDocument(context) {
    var predicate = NSPredicate.predicateWithFormat(
        'className == "MSSliceLayer" && name != "#9patch" && exportOptions.firstFormat == "svg"'
    );
    return context.document.allExportableLayers().filteredArrayUsingPredicate(predicate);
}

function optimizeSVG(svgo, svgIn) {
    var config = {
        plugins: [
            {
                convertColors: {
                    shorthex: false
                }
            },
            {
                cleanupListOfValues: {
                    floatPrecision: 2
                }
            },
            {
                cleanupNumericValues: {
                    floatPrecision: 2
                }
            },
            {
                convertPathData: {
                    floatPrecision: 2,
                    leadingZero: false
                }
            }
        ]
    };
    runCommand("/bin/bash", ["-l", "-c", svgo + " --config='" + JSON.stringify(config) + "' '" + svgIn + "'"]);
}

function svg2vector(s2v, svgFile, vectorFile) {
    runCommand("/bin/bash", ["-l", "-c", s2v + " '" + svgFile + "' '" + vectorFile + "'"]);
}

function checkVersion(command) {
    var result = "";
    runCommand("/bin/bash", ["-l", "-c", command + " --version"], function(status, msg) {
        if (status && msg != "") {
            result += msg;
            result = result.replace(/\s*$/g, "");
        }
    });
    return result;
}

function versionCompare(version1, version2) {
    var v1 = version1.split("."),
        v2 = version2.split(".");
    var length = Math.max(v1.length, v2.length);
    for (var i = 0; i < length; i ++) {
        var part1 = v1[i] ? parseInt(v1[i]) : 0,
            part2 = v2[i] ? parseInt(v2[i]) : 0;
        if (part1 < part2) {
            return -1;
        }
        if (part1 > part2) {
            return 1;
        }
    }
    return 0;
}
