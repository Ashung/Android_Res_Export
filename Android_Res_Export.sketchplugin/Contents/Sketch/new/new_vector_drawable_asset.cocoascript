@import "../lib/common.js";

var onRun = function(context) {

    var doc = context.document;
    var selection = context.selection;
    var selectionCount = selection.count();

    if (selectionCount == 0) {
        toast(context, localizedString(context, "no_selection"));
        return;
    }

    // Checking if layers containt not supported effect
    var supported = 1;

    var loopSelection = selection.objectEnumerator();
    var layer;
    while (layer = loopSelection.nextObject()) {
        checkLayerType(context, layer, selectionCount, function(sup) {
            supported = sup;
        });
        if (supported == 0) {
            return;
        }
    }

    // Asset name
    var dialog = COSAlertWindow.alloc().init();
    dialog.setMessageText(localizedString(context, "new_vector_drawable_asset"));
    dialog.setInformativeText(localizedString(context, "asset_name_for_vector_drawable"));
    dialog.addButtonWithTitle(localizedString(context, "ok"));
    dialog.addButtonWithTitle(localizedString(context, "cancel"));

    var iconPath = context.plugin.urlForResourceNamed("icon.png").path();
    var iconNSImage = NSImage.alloc().initWithContentsOfFile(iconPath);
    dialog.setIcon(iconNSImage);

    dialog.addTextFieldWithValue(selection.lastObject().name());
    var textField = dialog.viewAtIndex(0);
    dialog.alert().window().setInitialFirstResponder(textField);

    var removeInvisibleLayers = NSButton.alloc().initWithFrame(NSMakeRect(0, 0, 300, 20));
    removeInvisibleLayers.setButtonType(NSSwitchButton);
    removeInvisibleLayers.setTitle(localizedString(context, "remove_invisible_layers"));
    removeInvisibleLayers.setState(getPreferences(context, "remove_invisible_layers") == 1 ? NSOnState : NSOffState);
    dialog.addAccessoryView(removeInvisibleLayers);

    var responseCode = dialog.runModal();
    if (responseCode == 1000) {

        // Group vector
        if (
            selectionCount == 1 &&
            (
                selection.firstObject().class() == "MSLayerGroup" ||
                selection.firstObject().class() == "MSArtboardGroup" ||
                selection.firstObject().class() == "MSSymbolMaster"
            )
        ) {
            var groupVector = selection.firstObject();
        } else {
            var groupVector = groupFromSelection(context);
        }
        var name = textField.stringValue();
        groupVector.setName(androidResName(name));

        // Add slice
        var slice = addSliceInToGroup(groupVector, "#vector", true);
        var exportOption = slice.exportOptions().exportFormats().firstObject();
            exportOption.setFileFormat("svg");
            exportOption.setName("@android_res_export");

        // Move bitmap/text layer outside group
        var loopChild = groupVector.children().objectEnumerator();
        var child;
        while (child = loopChild.nextObject()) {
            if (child.class() == "MSBitmapLayer" || child.class() == "MSTextLayer") {
                child.moveToLayer_beforeLayer(
                    groupVector.parentGroup(),
                    groupVector.parentGroup().layerAtIndex(groupVector.parentGroup().indexOfLayer(groupVector) + 1)
                );
            }
            // remove invisible layers
            if (child.class() == "MSShapeGroup" && layerIsInvisible(child) && removeInvisibleLayers.state() == 1) {
                child.removeFromParent();
            }
        }

        if (removeInvisibleLayers.state() == 1) {
            setPreferences(context, "remove_invisible_layers", true);
        } else {
            setPreferences(context, "remove_invisible_layers", false);
        }

    }

    ga(context, "New", "new_vector_drawable");

};

function layerIsInvisible(layer) {

    if (!layer.isVisible()) {
        return true;
    }

    if (layer.isKindOfClass(MSStyledLayer)) {
        if (layer.style().contextSettings().opacity() == 0) {
            return true;
        }
    }

    if (layer.class() == "MSShapeGroup") {
        if (
            checkingFills(layer) &&
            checkingBorders(layer) &&
            checkingShadows(layer) &&
            checkingInnerShadows(layer)
        ) {
            return true;
        }
    }

    if (layer.class() == "MSTextLayer") {
        if (layer.style().enabledFills().count() == 0) {
            if (
                layer.textColor().alpha() == 0 &&
                checkingBorders(layer) &&
                checkingShadows(layer) &&
                checkingInnerShadows(layer)
            ) {
                return true;
            }
        } else {
            if (
                checkingFills(layer) &&
                checkingBorders(layer) &&
                checkingShadows(layer) &&
                checkingInnerShadows(layer)
            ) {
                return true;
            }
        }

    }

    return false;

}

function checkingFills(layer) {
    if (layer.style().enabledFills().count() == 0) {
        return true;
    }
    var loopFills = layer.style().enabledFills().objectEnumerator();
    var fill;
    while (fill = loopFills.nextObject()) {
        if (fill.fillType() == 0) {
            if (fill.color().alpha() != 0) {
                return false;
            }
        }
        if (fill.fillType() == 1 || fill.fillType() == 4 || fill.fillType() == 5) {
            if (fill.contextSettings().opacity() == 0) {
               return true;
            }
        }
        if (fill.fillType() == 1) {
            var gradientStops = fill.gradient().stops();
            var loopStops = gradientStops.objectEnumerator();
            var stop;
            while (stop = loopStops.nextObject()) {
                if (stop.color().alpha() != 0) {
                    return false;
                }
            }
        }
    }
    return true;
}

function checkingBorders(layer) {
    if (layer.style().enabledBorders().count() == 0) {
        return true;
    }
    var loopBorders = layer.style().enabledBorders().objectEnumerator();
    var borders;
    while (borders = loopBorders.nextObject()) {
        if (borders.fillType() == 0) {
            if (borders.color().alpha() != 0) {
                return false;
            }
        } else {
            if (borders.contextSettings().opacity() == 0) {
               return true;
            } else {
                var gradientStops = borders.gradient().stops();
                var loopStops = gradientStops.objectEnumerator();
                var stop;
                while (stop = loopStops.nextObject()) {
                    if (stop.color().alpha() != 0) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}

function checkingShadows(layer) {
    if (layer.style().enabledShadows().count() == 0) {
        return true;
    }
    var loopShadows = layer.style().enabledShadows().objectEnumerator();
    var shadow;
    while (shadow = loopShadows.nextObject()) {
        if (shadow.color().alpha() != 0) {
            return false;
        }
    }
    return true;
}

function checkingInnerShadows(layer) {
    if (layer.style().enabledInnerShadows().count() == 0) {
        return true;
    }
    var loopInnerShadows = layer.style().enabledInnerShadows().objectEnumerator();
    var innerShadows;
    while (innerShadows = loopInnerShadows.nextObject()) {
        if (innerShadows.color().alpha() != 0) {
            return false;
        }
    }
    return true;
}

function checkLayerType(context, layer, count, callback) {

    if (count > 1) {
        var loop = layer.layers().objectEnumerator();
        var item;
        while (item = loop.nextObject()) {
            if (item.class() == "MSArtboardGroup" || item.class() == "MSSymbolMaster") {
                toast(context, localizedString(context, "can_not_group_artboard"));
                callback(0);
            }
        }
    }

    if (layer.class() == "MSLayerGroup" || layer.class() == "MSArtboardGroup" || layer.class() == "MSSymbolMaster") {
        var loop = layer.layers().objectEnumerator();
        var item;
        while (item = loop.nextObject()) {
            checkLayerType(context, item, count, callback);
        }
    } else {

        if (layer.class() == "MSTextLayer") {
            toast(context, localizedString(context, "vector_drawable_no_support_text"));
            callback(0);
        }

        if (layer.class() == "MSBitmapLayer") {
            toast(context, localizedString(context, "vector_drawable_no_support_bitmap"));
            callback(0);
        }

        if (layer.class() == "MSSymbolInstance") {
            toast(context, localizedString(context, "vector_drawable_no_support_symbol_instance"));
            callback(0);
        }

        // Not suppot styles in vector drawable
        if (layer.class() == "MSShapeGroup") {
            if (layer.rotation() != 0) {
                toast(context, localizedString(context, "vector_drawable_no_support_rotation"));
                callback(0);
            }
            if (layer.isFlippedVertical() != 0 || layer.isFlippedHorizontal() != 0) {
                toast(context, localizedString(context, "vector_drawable_no_support_flipped"));
                callback(0);
            }
            if (layer.hasClippingMask() == 1) {
                toast(context, localizedString(context, "vector_drawable_no_support_mask"));
                callback(0);
            }

            var style = layer.style();
            if (style.enabledFills().count() > 0) {
                for (var i = 0; i < style.enabledFills().count(); i++) {
                    var fill =  style.enabledFills().objectAtIndex(i);
                    if (fill.fillType() != 0) {
                        toast(context, localizedString(context, "vector_drawable_no_support_fill"));
                        callback(0);
                    }
                }
            }
            if (style.enabledBorders().count() > 0) {
                for (var i = 0; i < style.enabledBorders().count(); i++) {
                    var border =  style.enabledBorders().objectAtIndex(i);
                    if (border.fillType() != 0) {
                        toast(context, localizedString(context, "vector_drawable_no_support_border"));
                        callback(0);
                    }
                }
            }
            if (style.enabledShadows().count() > 0) {
                toast(context, localizedString(context, "vector_drawable_no_support_shadow"));
                callback(0);
            }
            if (style.enabledInnerShadows().count() > 0) {
                toast(context, localizedString(context, "vector_drawable_no_support_inner_shadow"));
                callback(0);
            }
            if (style.blur().isEnabled()) {
                toast(context, localizedString(context, "vector_drawable_no_support_blur"));
                callback(0);
            }
        }

    }
}
